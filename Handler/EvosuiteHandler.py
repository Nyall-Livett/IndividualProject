import re
import os
from pathlib import Path
from Handler.Handler import Handler
from File.FileIO import FileIO
from Generation.TestRunner import TestRunner
from Helper.PathHelper import PathHelper
from Helper.TerminalPrinter import TerminalPrinter

class EvosuiteHandler(Handler):

    CSV_HEADERS: list = [
        "EVOSUITE_mutation_score",
        "EVOSUITE_code_coverage"
        ]

    DISABLED_IMPORT: str = "import org.junit.jupiter.api.Disabled;"

    def __init__(self, 
                 test_runner,
                 test_path,
                 class_path,
                 class_name,
                 result,
                 ) -> None:
        self.test_runner : TestRunner = test_runner
        self.test_path = test_path
        self.class_path = class_path
        self.path_helper = PathHelper()
        self.result = result
        self.class_name = class_name
        self.file_handler = FileIO()
        self.printer = TerminalPrinter()

    @classmethod
    def get_csv_headers(cls):
        """
        Return the headers used in CSV file. Must be overriden from ABC
        """
        return cls.CSV_HEADERS

    def _copy_file(self, evosuite_path, test_path):
        """
        Copys the files generated by Evosuite into the package
        """
        test_set_path = Path(test_path).parent
        ret = self.file_handler.copy_file(evosuite_path, test_set_path)
        package_name = self.path_helper._determine_full_package_name(test_path)
        self.file_handler.update_package_in_file(test_path, package_name)
        return ret

    def __sanatise_file(self, test_path):
        """
        Prepare the file to be run by JUnit + mvn without the EvosuiteRunner
        so it can be picked up by PITest and can get mutation report.
        """
        self.printer.print_with_color("Sanitising Evosuite file", "yellow")
        annotations_to_remove = [
            r'@EvoRunnerParameters\s*\(.*?\)',
            r'@RegisterExtension\s+static\s+EvoRunnerJUnit5\s+runner\s*=\s*new\s+EvoRunnerJUnit5\(\s*\w+_ESTest\.class\s*\)\s*;',
            r'\bextends\s+\w+_ESTest_scaffolding\b'
        ]

        self.file_handler.remove_from_file(test_path, annotations_to_remove)

        package_name = self.path_helper._determine_full_package_name(test_path)
        self.file_handler.update_package_in_file(test_path, package_name)


    def execute(self):
    
        # Execute Evosuite
        self.test_runner.run_evosuite(self.test_path, self.class_path)
        
        # Try a number of ways to locate the file, returns the file path if found, otherwise None
        evosuite_test_path = self.is_file_generated(self.test_path, self.class_path)

        if evosuite_test_path is None:
            self.printer.print_with_color(f"Error can not find the generated tests by Evosuite {self.test_path}", "red")
            self.result.values.append("FailedToGenerate")
            self.result.values.append("FailedToGenerate")
            return None
        
        # Copy the both test suite and scaffolding to the test suite of the package
        new_evosuite_path = self._copy_file(evosuite_test_path, self.test_path)
        scaffolding_path = evosuite_test_path.split(".java")[0]+ "_scaffolding.java"
        self._copy_file(scaffolding_path, self.test_path)
        self.__sanatise_file(new_evosuite_path)
        ret = self.test_runner.run_unit_test(new_evosuite_path)

        # Error when running subprocess
        if ret is None:
            self.result.values.append("FailedToGenerate")
            self.result.values.append("FailedToGenerate")
            return None

        # Deal with failures if there are any in the standard output. 
        if self.has_failures(ret.stdout):
            self.handle_failures(self.test_path, new_evosuite_path, ret.stdout)
            second_ret = self.test_runner.run_unit_test(new_evosuite_path)

            if self.has_failures(second_ret.stdout):
                self.result.values.append("FailedToGenerate")
                self.result.values.append("FailedToGenerate")
                return

        overview_tuple, _ = self.test_runner.run_mutation_test(new_evosuite_path, self.class_name, self.result, self.class_path)
        
        # Error when running subprocess due to time out probably
        # I need to sanitise the file and run it normally now without Evosuite.
        if overview_tuple is False:
            self.__sanatise_file(new_evosuite_path)
            overview_tuple, _ = self.test_runner.run_mutation_test(new_evosuite_path, self.class_name, self.result, self.class_path)

        if overview_tuple is None or overview_tuple is False:
            self.result.values.append("NoReport")
            self.result.values.append("NoReport")
            self.printer.print_with_color("NoReport", "yellow")
            return

        self.printer.print_with_color(overview_tuple, "yellow")

        # Update result object
        self.result.values.append(overview_tuple.mutation_score_percent)
        self.result.values.append(overview_tuple.code_coverage_percent)

    
    def handle_failures(self, test_path, new_evosuite_path, stdout):

        # Parse the output and try to extract names of the tests that are causing the errors and failures
        failure_test_names = self.find_failure_test_names(stdout)            
    

        if len(failure_test_names) != 0:

            self.file_handler.add_import_in_file(new_evosuite_path, self.DISABLED_IMPORT)


            # Read the file using the new path after copying to the package
            str_file = self.file_handler.read_file_as_string(new_evosuite_path)

            # Need to insert the @Disabled annotation at the top of the file so it
            # cause a complilation error

            # Iterate through and add annotation above erroneous tests
            for test_name in failure_test_names:
                pattern = r'(public void ' + re.escape(test_name) + r'\(\))'
                replacement = r'@Disabled\n    ' + r'\1'
                str_file = re.sub(pattern, replacement, str_file, flags=re.MULTILINE)
                print(f"Disabled test: {test_name}")

            self.file_handler.write_file_from_string(new_evosuite_path, str_file)
            

    def is_file_generated(self, test_path, class_path: str):
        """
        Check to see if the files generated by Evosuite have been generated and can be found.
        """
        # The tests and classes can have different package names
        # Try to find the file using the class package name.
        evosuite_class_path, _ = self.path_helper._determine_evosuite_test_paths(class_path)
        if os.path.exists(Path(evosuite_class_path)):
            return evosuite_class_path
        
        # If that doest exist try to find it using the package of the test.
        sanitised_test_path = str(test_path).replace("Test", "")
        evosuite_test_path, _ = self.path_helper._determine_evosuite_test_paths(sanitised_test_path)
        if os.path.exists(Path(evosuite_test_path)):
            return evosuite_test_path
        
        # If that doesnt work do a path walk. Will return None if file is not found
        root = self.path_helper._determine_root_directory_path(test_path)
        return self.file_handler.find_file(root, Path(evosuite_test_path).name)


    def has_failures(self, test_output):
        """
        Parses the standard output and checks if there are errors in it.
        """
        match = re.search(r"Failures:\s*(\d+),\s*Errors:\s*(\d+)", test_output)
        match2 = re.search(r"Build Failure", test_output)        
        match3 = re.search(r"Compilation Error", test_output)
                        
        if match2 or match3:
            return True
            
        if match:
            failures = int(match.group(1))
            if failures > 0:
                return True

            errors = int(match.group(2))
            if errors > 0:
                return True
            return False


    def find_failure_test_names(self, output):
        """
        Trys to extract the tests that are causing failures
        """

        failed_tests = []
        pattern = r"\w+_ESTest\.test(\d+):\d+ expected:"
        failed_tests.extend(re.findall(pattern, output))
                    
        pattern2 = r"\w+_ESTest\.test(\d+):\d+ Expecting exception:"
        failed_tests.extend(re.findall(pattern2, output))
        
        pattern3 = r"\w+_ESTest\.test(\d+):\d+\s*.\s*IllegalArgument"
        failed_tests.extend(re.findall(pattern3, output))
                
        pattern4 = r"\w+_ESTest\.test(\d+):\d+ Exception"
        failed_tests.extend(re.findall(pattern4, output))
                
        pattern5 = r"\w+_ESTest\.test(\d+) -- Time elapsed:\d+(\.\d?)? s <<< ERROR!"
        failed_tests.extend(re.findall(pattern5, output))
                
        pattern6 = r"\w+_ESTest\.test(\d+):\d+.\s*IllegalArgument"
        failed_tests.extend(re.findall(pattern6, output))
        
        pattern7 = r"\w+_ESTest\.test(\d+):\d+\s*.\s*MockIllegalArgument"
        failed_tests.extend(re.findall(pattern7, output))
                
        pattern8 = r"\w+_ESTest\.test(\d+):\d+.\s*MockIllegalArgument"
        failed_tests.extend(re.findall(pattern6, output))
        return [f"test{test_number}" for test_number in failed_tests]
